---
title: "Compara métodos de campo y dron (paper SUDOE)"
author: "ajpelu"
date: "2022-04-18"
output: 
  bookdown::html_document2:
    base_format: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r global-options, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, 
                      warning=FALSE, message=FALSE)
```

```{r pkg}
library(tidyverse)
library(here)
library(janitor)
library(ggdark)
library(ggforce)
library(ggpubr)
library(colorspace)
library(ggstatsplot)
library(Metrics)
library(ggdist)
library(performance)
library(cvequality)
library(kableExtra)
library(report)
library(tweedie)
library(statmod)
library(PMCMR)
library(PMCMRplus)
library(ggtext)
library(pairwiseComparisons)
library(ggstatsplot)
library(ggsignif)
library(statsExpressions)
library(rpart)
library(party)
library(ggparty)
library(partykit)

# Notas sobre anova
# https://bcdudek.net/anova/index.html
# http://www.alexanderdemos.org/ANOVA6.html
```

```{r read-data}
fit_t <- readxl::read_excel(here::here("data/Datos_boxplot_metodos.xlsx"), 
                              sheet = "fitovolumen_transectos") %>% janitor::clean_names() 

fit_q <- readxl::read_excel(here::here("data/Datos_boxplot_metodos.xlsx"), 
                              sheet = "fitovolumen_quadrat") %>% janitor::clean_names() 

cob_t <- readxl::read_excel(here::here("data/Datos_boxplot_metodos.xlsx"), 
                              sheet = "cobertura_transectos") %>% janitor::clean_names() 

cob_q <- readxl::read_excel(here::here("data/Datos_boxplot_metodos.xlsx"), 
                              sheet = "cobertura_quadrat") %>% janitor::clean_names() 

riq_t <- readxl::read_excel(here::here("data/Datos_boxplot_metodos.xlsx"), 
                              sheet = "riqueza_transectos") %>% janitor::clean_names()

div_t <- readxl::read_excel(here::here("data/Datos_boxplot_metodos.xlsx"), 
                              sheet = "diversidad_transectos") %>% janitor::clean_names()

riqdiv_q <- readxl::read_excel(here::here("data/Datos_boxplot_metodos.xlsx"), 
                              sheet = "riqueza_div_quadrat") %>% janitor::clean_names()
```

```{r}
cob_qlonger <- cob_q %>% dplyr::select(zona, parcela, quadrat = plot, dronQ = dron) %>% 
  pivot_longer(cols = c("dronQ", "quadrat"))

cob_tlonger <- cob_t %>% 
  dplyr::select(-transecto) %>% 
  rename(dronT = dron) %>% 
  pivot_longer(cols = c("dronT", "line_intercept","point_quadrat"))

cober <- bind_rows(cob_qlonger, cob_tlonger) %>% 
  mutate(metodo = fct_relevel(name, c("quadrat","dronQ","line_intercept","point_quadrat", "dronT"))) %>% 
  mutate(variable = "Cobertura")

fit_qlonger <- fit_q %>% dplyr::select(zona, parcela, quadrat = plot, dronQ = dron) %>% 
  pivot_longer(cols = c("dronQ", "quadrat"))

fit_tlonger <- fit_t %>% 
  dplyr::select(-transecto, -fecha_muestreos) %>% 
  rename(line_intercept = line_interc) %>% 
  rename(dronT = dron) %>% 
  pivot_longer(cols = c("dronT", "line_intercept"))

fit <- bind_rows(fit_qlonger, fit_tlonger) %>% 
  mutate(metodo = fct_relevel(name, c("quadrat","dronQ","line_intercept", "dronT"))) %>% 
  mutate(variable = "Fitovolumen")

riqdiv_q_longer <- riqdiv_q %>% dplyr::select(zona = nombre_zona, 
                                              parcela = geo_parcela_nombre, 
                                              quadrat_riqueza,
                                              quadrat_diversidad) %>% 
  pivot_longer(cols = c("quadrat_riqueza","quadrat_diversidad")) %>% 
  separate(name, into=c("metodo", "variable"), sep="_", remove = FALSE)


riq_tlonger <- riq_t %>% 
  pivot_longer(cols = c("line_intercept","point_quadrat","point_quadrat_extenso","quadrat_parcela")) %>% 
  mutate(variable = "riqueza", metodo = name)

div_tlonger <- div_t %>% 
  pivot_longer(cols = c("line_intercept","point_quadrat")) %>% 
  mutate(variable = "diversidad", metodo = name)

d <- bind_rows(cober, fit, riqdiv_q_longer, riq_tlonger, div_tlonger)

d <- d %>% mutate(metodo = fct_recode(metodo, 
                                      "Cuadrado" = "quadrat",
                                      "Line intercept" = "line_intercept",
                                      "Point quadrat" = "point_quadrat",
                                      "Cuadrado parcela" = "quadrat_parcela"))


```

```{r}
# Auxiliar functions 
comparaKW <- function(df, mivariable, group_variable, alpha_posthoc){ 
  require(PMCMRplus)
  require(multcompView) 
  
  output <- list() 
  
  # Model formulation
  myformula <- as.formula(paste0(mivariable, " ~ " , group_variable))
  
  # Kruskal Wallis  
  kt <- kruskal.test(myformula, data = df) 
  
  # Summary AOV (broom style)
  tm <- broom::tidy(kt)
  tm$mi_variable <- mivariable
  
  # Dunn's test 
  # object <- PMCMR::posthoc.kruskal.dunn.test(myformula, data=df, p.adjust.method = "bonferroni")
  object <- PMCMRplus::kwAllPairsDunnTest(myformula, data=df, p.adjust.method = "bonferroni")
  
  # Get dataframe with letters and pvalues (#from summary.PMCMR)
  pval <- as.numeric(object$p.value)
  stat <- as.numeric(object$statistic)
  grp1 <- as.numeric(c(col(object$p.value)))
  cnam <- colnames(object$p.value)
  grp2 <- as.numeric(c(row(object$p.value)))
  rnam <- rownames(object$p.value)
  H0 <- paste(cnam[grp1], " = ", rnam[grp2])
  OK <- !is.na(pval)
  xdf <- data.frame(H0 = H0[OK], statistic = stat[OK], p.value = as.numeric(format.pval(pval[OK], 5)))
  
  # Get letters (using multcompView) See viggnete PMCMR 
  dt_letters  <- multcompView::multcompLetters(PMCMR::get.pvalues(object), threshold = alpha_posthoc)
 
  output$KW <- tm
  output$post_hoc <- xdf
  output$letters <- dt_letters
  return(output)
}


format_letters <- function(kw, group_variable){
  l <- as.data.frame(kw$letters$Letters)
  l$v <- row.names(l)
  colnames(l) <- c('letter', group_variable)
  row.names(l) <- NULL
  return(l)
}

comparaCV <- function(x, group_variable) {
  # function to compute pairwise comparisons of CV equality test 
  # see cvequality to perform a CV equality test between samples
  # here I created a function to compute test of CV equality among each
  # pairwise of the group_variable
  # march 2022 
  
  require(cvequality)
  require(dplyr)
  
  set.seed(123)
  # Genera combinations of the grouping variable
  ## vector of combinations
  v <- x[group_variable] %>% pull()
  combinaciones <- combn(v, 2, simplify = FALSE)
  
  # Out dataframe 
  cv_df <- c()
  
  for (i in 1:length(combinaciones)){
    out <- t(as.matrix(combinaciones[[i]], nrow=1)) %>% as.data.frame()
    df <- x %>% filter(.data[[group_variable]] %in% combinaciones[[i]]) 
    test_cv <- cvequality::mslr_test2(nr=9999, n=df$n, s=df$sd, x=df$mean, seed=123)
    
    out$MSLRT <- test_cv$MSLRT
    out$p_value <- as.numeric(format(test_cv$p_value, scientific = FALSE))
    
    cv_df <- rbind(cv_df, out)
  }
  return(cv_df)
  
}


```


# Objetivo 1. Carga de combustible: cobertura y fitovolumen 

## Cobetura 

Vamos a realizar la comparación seleccionando para cada parcela (n=12) un valor de cobertura de quadrats (quadrats medio). 

```{r}
# ojo no eliminar el fct_relevel ... si no deja de funcionar una funcion de pairwise
cob <- d %>% filter(variable == "Cobertura") %>% 
  mutate(metodo = fct_relevel(metodo, 
                              c("Cuadrado","dronQ","Line intercept","Point quadrat", "dronT"))) 
```


```{r}
cob_qcorrected <- readxl::read_excel(here::here("data/Cobertura_fitovolumen_corregido_parcela.xlsx")) %>% janitor::clean_names() %>% 
  dplyr::select(parcela, value=cobertura_cor) %>% 
  mutate(metodo = "Cuadrado media ponderada")
```

```{r}
cob_doce <- 
  cob %>% 
 filter(metodo %in% c("dronT", "Line intercept", "Point quadrat")) %>% 
  dplyr::select(parcela, value, metodo) %>% 
  bind_rows((
    cob_q %>% 
  group_by(parcela) %>% 
  summarize(value = mean(plot)) %>% 
  mutate(metodo = "Cuadrado medio"))) %>% 
    bind_rows(cob_qcorrected)
  
```


### Summary values 
```{r cob-resumen}
scob <- cob_doce %>% 
  filter(metodo %in% c("Line intercept","Point quadrat", "Cuadrado medio")) %>% 
  group_by(metodo) %>% 
  summarise(mean = mean(value, na.rm = TRUE), 
            sd = sd(value, na.rm = TRUE), 
            se = sd/sqrt(length(value)),
            cv = sd/mean*100,
            median = median(value, na.rm=TRUE),
            min = min(value), 
            max = max(value),
            n = length(value))

scob %>% kable(digits = 2,
               caption = "Cobertura || Summary") %>% 
    kable_paper("hover", full_width = F)
```

### Comparación de métodos 

- ANOVA Kruskal Wallis 

```{r cob-kw}
kw_cob_doce <- cob_doce %>% 
    filter(metodo %in% c("Line intercept","Point quadrat", "Cuadrado medio")) %>% mutate(metodo = fct_relevel(metodo, 
                              c("Line intercept",
                                "Point quadrat", 
                                "Cuadrado medio"))) %>% 
  rename(cobertura = value) %>% 
  comparaKW('cobertura', 'metodo', alpha_posthoc = 0.05)

kw_cob_doce$KW %>% kbl(caption = "Cobertura || Non-parametric Kruskal-Wallis ANOVA") %>% 
  kable_paper("hover", full_width = F)
```


Los resultados de la ANOVA no paramétrica (Kruskal-Wallis) indican que existen diferencias significativas para la cobertura (%) entre los diferentes métodos de campo empleados ($\chi^2$ = `r paste0(round(kw_cob_doce$KW$statistic,2),"; ", scales::pvalue(kw_cob_doce$KW$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`) (Tabla \@ref(tab:cob-kw)).


Posteriormente, evaluamos si existen diferencias entre cada uno de los métodos (*post hoc*) y observamos que existen diferencias significativas entre el **point quadrat** y los otros métodos (**line intercept** y **quadrat medio**) (Tabla \@ref(tab:cob-ph), Figura \@ref(fig:cob-violin)). Asimismo, no observamos diferencias entre la cobertura estimada según el line intercept y el quadrat medio. 

```{r cob-ph}
kw_cob_doce$post_hoc %>% 
  mutate(p.value = scales::pvalue(p.value, accuracy = 0.001)) %>% 
  kable(digits = c(0,2,4), caption = "Cobertura || Non-parametric Kruskal-Wallis ANOVA - Post-hoc Dunn's-test with Bonferroni adjustment") %>% 
    kable_paper("hover", full_width = F)
```


```{r cob-violin, fig.cap="Comparación de los valores de cobertura entre los diferentes métodos de campo."}

p <- cob_doce %>% 
  filter(metodo %in% c("Line intercept","Point quadrat", "Cuadrado medio")) %>%
  mutate(metodo = fct_recode(metodo, "Cuadrado" = "Cuadrado medio"))

  
set.seed(123)
p1_cob <- ggbetweenstats(p, 
               x = metodo, 
               y= value, 
               type = "np",
               ylab = "Cobertura (%)", 
               xlab = "Método",
               p.adjust.method = "bonferroni", 
               pairwise.display = "s", 
               centrality.label.args = list(size = 3, nudge_x = -0.4)) 

p1_cob
```

### Correlación 
El siguiente paso es evaluar la correlación que existe entre los métodos de campo para la cobertura. 

```{r}
correla_pares <- function(df, vselected, xlab, ylab, ...){ 
  
  dftemp <- df %>% 
    pivot_wider(names_from = metodo) %>% 
    pivot_longer(cols = -c(vselected, parcela))

  ggscatter(dftemp, x = "value", 
          y = vselected, 
          add = "reg.line", conf.int = TRUE, 
          color = "name", shape = "name",
          xlab = xlab,
          ylab = ylab, ...) +  
  geom_abline(slope = 1) + 
  stat_cor(
    label.y.npc="top", label.x.npc = "left",
    aes(color = name, 
        label = paste(..rr.label.., ..p.label.., sep = "~`,`~"), 
        ),
    show.legend = FALSE
    )  
  
  }
```

Tal y como observamos en la Figura \@ref(fig:cob-correla), existe una correlación significativa del **line intercept** con el **point quadrat** ($R^2=$ 0.63), aunque lejos del ajuste perfecto (línea negra en Figura \@ref(fig:cob-correla)). El método **point quadrat** sobreestima los valores de cobertura con respecto al método de **line intercept**. Así, el rango de cobertura estimado por el LI varía entre 11.95-34 %, mientras que la estimación por PQ varía entre 41-64% (Tabla \@ref(tab:cob-resumen)). La correlación entre **quadrat medio** y **point quadrat** es muy baja (Figura \@ref(fig:cob-correlaQM-PQ)). 

```{r}
color_a <- "#023FA5" 
color_b <- "#004B40"
color_c <- "#533600"

```


```{r cob-correla, fig.cap="Correlación entre los valores de cobertura estimados por Line Intercept y los otros métodos de campo: Point Quadrat y Quadrat medio."}
c1_cob_a <- cob_doce %>% 
  filter(metodo %in% c("Line intercept","Point quadrat", "Cuadrado medio")) %>% 
  mutate(metodo = fct_recode(metodo, "Cuadrado" = "Cuadrado medio")) %>% 
  correla_pares("Cuadrado", 
                xlab = "Cobertura (%)", 
                ylab = "Cobertura (%) \n Cuadrado") +
  xlim(0,80) + ylim(0,80)+ 
  scale_shape_manual(values = c(19,15), name = "") +
  scale_colour_manual(values = c(color_b,color_c), name = "") + 
  scale_fill_manual(values = c(color_b,color_c), name = "") +
  theme(panel.margin = unit(c(0, 0, 0, 0), "cm"))  

c1_cob_a
```

#### Correlación Quadrat medio - Point Quadrat 


```{r cob-correlaQM-PQ, fig.cap="Correlación entre los valores de cobertura estimados por Quadrat medio y Point Quadrat."}
c1_cob_b <- cob_doce %>% 
  filter(metodo %in% c("Point quadrat", "Line intercept")) %>% 
  correla_pares("Line intercept", 
                xlab = "Cobertura (%)\n Point Quadrat", 
                ylab = "Cobertura (%)\n Line intercept") +
  xlim(0,80) + ylim(0,80) + 
  scale_shape_manual(values = 17, name = "") +
  scale_colour_manual(values = color_a, name = "") + 
  scale_fill_manual(values = color_a, name = "") +
  theme(legend.position = "none", 
        panel.margin = unit(c(0, 0, 0, 0), "cm"))

c1_cob_b 
```


## Fitovolumen

- En este caso solo compararemos los métodos de Line Intercept y Quadrat medio 
```{r}
# ojo no eliminar el fct_relevel ... si no deja de funcionar una funcion de pairwise
fit <- d %>% filter(variable == "Fitovolumen") %>% 
  mutate(metodo = fct_relevel(metodo, 
                              c("Cuadrado","dronQ","Line intercept","dronT"))) 
```


```{r}
fit_doce <- 
  fit %>% 
 filter(metodo %in% c("dronT", "Line intercept", "Point quadrat")) %>% 
  dplyr::select(parcela, value, metodo) %>% 
  bind_rows((
    fit_q %>% 
  group_by(parcela) %>% 
  summarize(value = mean(plot)) %>% 
  mutate(metodo = "Cuadrado medio")))
  
```

### Summary values 
```{r fit-resumen}
scob <- fit_doce %>% 
  filter(metodo %in% c("Line intercept","Cuadrado medio")) %>% 
  group_by(metodo) %>% 
  summarise(mean = mean(value, na.rm = TRUE), 
            sd = sd(value, na.rm = TRUE), 
            se = sd/sqrt(length(value)),
            cv = sd/mean*100,
            median = median(value, na.rm=TRUE),
            min = min(value), 
            max = max(value),
            n = length(value))

scob %>% kable(digits = 2,
               caption = "Fitovolumen || Summary") %>% 
    kable_paper("hover", full_width = F)
```

### Comparación de métodos 

```{r}
fit_selected <- fit_doce %>% 
  filter(metodo %in% c("Line intercept","Cuadrado medio")) %>% 
  mutate(metodo = fct_recode(metodo, "Cuadrado" = "Cuadrado medio"))  
```


```{r}
# normalidad
s <- shapiro.test(fit_selected$value)

# homocedasticidad
b <- bartlett.test(fit_selected$value, fit_selected$metodo, data=fit_selected)
```

Hemos comprobado Normalidad (`r paste0("W = ",round(s$statistic,2),  "; ",  scales::pvalue(s$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`);  y homocedasticidad (`r paste0("Bartlett's K-squared = ", round(b$statistic, 2),"; ", scales::pvalue(b$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`) y se puede aplicar un método paramétrico, en este caso, la t-student de comparación de medias. Observamos que existen diferencias (Figura \@ref(fig:fit-violin)): 

```{r }
fit_t <- t.test(value ~ metodo, data = fit_selected, var.equal = TRUE)
```


```{r}
report(fit_t)
```


```{r fit-violin, fig.cap="Comparación de los valores de fitovolumen entre Line Intercept y Quadrat medio."}


set.seed(123)
p1_fit <- ggbetweenstats(fit_selected, 
               x = metodo, 
               y= value, 
               type = "p",
               xlab = "Método",
               var.equal = TRUE,
               ylab=expression(bold(Fitovolumen~(m^3~ha^{-1})))) 

p1_fit
```

### Correlación 
No existe una buena correlación entre los valores de fitovolumen estimados con **line intercept** y los estimados con **quadrat medio** (Figura \@ref(fig:fit-correla)). Este último método sobreestima el fitovolumen registrado por el LI (ver Tabla \@ref(tab:fit-resumen)). 

```{r fit-correla, fig.cap="Correlación entre los valores de fitovolumen estimados por Line Intercept y Quadrat medio."}

c1_fit <- fit_selected %>% 
  correla_pares("Cuadrado", 
                xlab = expression(atop(paste("Fitovolumen (", m^3~ha^{-1}, ")"),
                     "Line Intercept")),
                ylab = expression(atop(paste("Fitovolumen (", m^3~ha^{-1}, ")"),
                     "Cuadrado"))) +
  xlim(0,1500) + ylim(0,1500) + 
  theme(legend.position = "none") + 
  scale_shape_manual(values = 17, name = "") +
  scale_colour_manual(values = color_a, name = "") + 
  scale_fill_manual(values = color_a, name = "")

c1_fit 

```


# Objetivo 2. Diversidad y Riqueza

## Riqueza

Comparamos entre line intercept, quadrat parcela y point quadrat. 

```{r}
# ojo no eliminar el fct_relevel ... si no deja de funcionar una funcion de pairwise
riq <- d %>% 
  filter(variable == "riqueza") %>% 
  mutate(metodo = 
           fct_relevel(metodo, 
                              c("Line intercept","Point quadrat","Cuadrado","point_quadrat_extenso","Cuadrado parcela"))) 

riq_selected <- riq %>% filter(metodo %in% c("Line intercept","Point quadrat","Cuadrado parcela")) 
```


### Summary values 
```{r riq-resumen}
sriq <- riq_selected  %>% 
  group_by(metodo) %>% 
  summarise(mean = mean(value, na.rm = TRUE), 
            sd = sd(value, na.rm = TRUE), 
            se = sd/sqrt(length(value)),
            cv = sd/mean*100,
            median = median(value, na.rm=TRUE),
            min = min(value), 
            max = max(value),
            n = length(value))

sriq %>% kable(digits = 2,
               caption = "Riqueza || Summary") %>% 
    kable_paper("hover", full_width = F)
```

### Comparación de métodos 

```{r, eval=FALSE}
aov_riq <- aov(value~metodo, riq_selected)
check_homogeneity(aov_riq)
check_normality(aov_riq)
```

- ANOVA Kruskal Wallis 

```{r riq-kw}
kw_riq <- riq_selected %>% 
  mutate(metodo = fct_relevel(metodo, 
                              c("Line intercept",
                                "Point quadrat", 
                                "Cuadrado parcela"))) %>% 
  rename(riqueza = value) %>% 
  comparaKW('riqueza', 'metodo', alpha_posthoc = 0.05)

kw_riq$KW %>% kbl(caption = "Riqueza || Non-parametric Kruskal-Wallis ANOVA") %>% 
  kable_paper("hover", full_width = F)
```


Los resultados de la ANOVA no paramétrica (Kruskal-Wallis) indican que existen diferencias significativas para la riqueza de especies vegetales entre los diferentes métodos de campo empleados ($\chi^2$ = `r paste0(round(kw_riq$KW$statistic,2),"; ", scales::pvalue(kw_riq$KW$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`) (Tabla \@ref(tab:riq-kw)).


Posteriormente, evaluamos si existen diferencias entre cada uno de los métodos (*post hoc*) y observamos que existen diferencias significativas entre el **quadrat parcela** y los otros métodos (**line intercept** y **point quadrat**) (Tabla \@ref(tab:riq-ph), Figura \@ref(fig:riq-violin)). Asimismo, no observamos diferencias entre la riqueza estimada según el line intercept y el point quadrat. 

```{r riq-ph}
kw_riq$post_hoc %>% 
  mutate(p.value = scales::pvalue(p.value, accuracy = 0.001)) %>% 
  kable(digits = c(0,2,4), caption = "Riqueza || Non-parametric Kruskal-Wallis ANOVA - Post-hoc Dunn's-test with Bonferroni adjustment") %>% 
    kable_paper("hover", full_width = F)
```



```{r riq-violin, fig.cap="Comparación de los valores de riqueza entre los diferentes métodos de campo."}

riq_selected <- riq_selected %>% 
  mutate(metodo = fct_recode(metodo, "Cuadrado" = "Cuadrado parcela"))

set.seed(123)
p1_riq <- ggbetweenstats(riq_selected, 
               x = metodo, 
               y= value, 
               type = "p",
               xlab = "Método",
               ylab = "Riqueza (nº especies)", 
               p.adjust.method = "bonferroni", 
               pairwise.display = "s")
p1_riq 
```

### Correlación 

Tal y como observamos en la Figura \@ref(fig:riq-correla), los métodos de **line intercept** y **point quadrat**, subestiman la riqueza estimada por el método **quadrat parcela**. Asimismo observamos una buena correlación entre la riqueza estimada por **line intercept** y **point quadrat** (Figura \@ref(fig:riq-correlaLI-PQ)) ($R^2=$ 0.66). 

```{r riq-correla, fig.cap="Correlación entre los valores de riqueza estimados por Quadrat Parcela y los otros métodos de campo: Line Intercept y Point Quadrat"}

c1_riq_a <- riq_selected %>% 
  dplyr::select(parcela, value, metodo) %>% 
  correla_pares("Cuadrado", 
                xlab = "Riqueza (nº especies)", 
                ylab = "Riqueza (nº especies) \n Cuadrado") + 
  xlim(0,60) + ylim(0,60) + 
  scale_shape_manual(values = c(19,15), name = "") +
  scale_colour_manual(values = c(color_b,color_c), name = "") + 
  scale_fill_manual(values = c(color_b,color_c), name = "") 

c1_riq_a 
```

#### Correlación Line Intercept - Point Quadrat 

```{r riq-correlaLI-PQ, fig.cap="Correlación entre los valores de riqueza estimados por Line Intercept y Point Quadrat"}
c1_riq_b <- riq_selected %>% 
  dplyr::select(parcela, value, metodo) %>% 
  filter(metodo %in% c("Line intercept","Point quadrat")) %>%  
  correla_pares("Line intercept", 
                xlab = "Riqueza (nº especies)\n Point Quadrat", 
                ylab = "Riqueza (nº especies)\n Line intercept") + 
 #  xlim(5,25) + ylim(5,25) + 
  scale_shape_manual(values = 17, name = "") +
  scale_colour_manual(values = color_a, name = "") + 
  scale_fill_manual(values = color_a, name = "") +
  theme(legend.position = "none")

c1_riq_b 
```


## Diversidad

Comparamos entre line intercept, quadrat medio y point quadrat.

```{r}
# ojo no eliminar el fct_relevel ... si no deja de funcionar una funcion de pairwise
div <- d %>% filter(variable == "diversidad") %>% 
  mutate(metodo = fct_relevel(metodo, 
                              c("Cuadrado","Line intercept","Point quadrat"))) 

div_selected <- 
  div %>% dplyr::select(parcela, value, metodo) %>% 
  filter(metodo != "Cuadrado") %>% 
  bind_rows(
    div %>% dplyr::select(parcela, value, metodo) %>% 
      filter(metodo == "Cuadrado") %>% 
      group_by(parcela) %>% 
      summarise(value = mean(value)) %>% 
      mutate(metodo = "Cuadrado medio")
  ) %>% 
  mutate(value = abs(value))
  
```


### Summary values 
```{r div-resumen}
sdiv <- div_selected  %>% 
  group_by(metodo) %>% 
  summarise(mean = mean(value, na.rm = TRUE), 
            sd = sd(value, na.rm = TRUE), 
            se = sd/sqrt(length(value)),
            cv = sd/mean*100,
            median = median(value, na.rm=TRUE),
            min = min(value), 
            max = max(value),
            n = length(value))

sdiv %>% kable(digits = 2,
               caption = "Diversidad (Shannon Index) || Summary") %>% 
    kable_paper("hover", full_width = F)
```

### Comparación de métodos 

```{r, eval=FALSE}
aov_div <- aov(value~metodo, div_selected)
check_homogeneity(aov_div)
check_normality(aov_div)
```

- ANOVA Kruskal Wallis 

```{r div-kw}
kw_div <- div_selected %>% 
  mutate(metodo = fct_relevel(metodo, 
                              c("Line intercept",
                                "Point quadrat", 
                                "Cuadrado medio"))) %>% 
  rename(diversidad = value) %>% 
  comparaKW('diversidad', 'metodo', alpha_posthoc = 0.05)

kw_div$KW %>% kbl(caption = "Diversidad || Non-parametric Kruskal-Wallis ANOVA") %>% 
  kable_paper("hover", full_width = F)
```


Los resultados de la ANOVA no paramétrica (Kruskal-Wallis) indican que existen diferencias significativas para la riqueza de especies vegetales entre los diferentes métodos de campo empleados ($\chi^2$ = `r paste0(round(kw_div$KW$statistic,2),"; ", scales::pvalue(kw_div$KW$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`) (Tabla \@ref(tab:div-kw)).


Posteriormente, evaluamos si existen diferencias entre cada uno de los métodos (*post hoc*) y observamos que solamente existen diferencias significativas entre el **point quadrat** y el **quadrat medio** (Tabla \@ref(tab:div-ph), Figura \@ref(fig:div-violin)).  

```{r div-ph}
kw_div$post_hoc %>% 
  mutate(p.value = scales::pvalue(p.value, accuracy = 0.001)) %>% 
  kable(digits = c(0,2,4), caption = "Diversidad || Non-parametric Kruskal-Wallis ANOVA - Post-hoc Dunn's-test with Bonferroni adjustment") %>% 
    kable_paper("hover", full_width = F)
```



```{r div-violin, fig.cap="Comparación de los valores de diversidad (Shannon) entre los diferentes métodos de campo."}


div_selected <- div_selected %>% 
    mutate(metodo = fct_recode(metodo, "Cuadrado" = "Cuadrado medio"))

set.seed(123)
p1_div <- ggbetweenstats(div_selected, 
               x = metodo, 
               y= value, 
               type = "np",
               xlab = "Método",
               ylab = "Diversidad (índice Shannon)", 
               p.adjust.method = "bonferroni", 
               pairwise.display = "s")

p1_div
```

### Correlación 

El método **line intercept** subestima la diversidad en comparación con el método **point quadrat** (Figura \@ref(fig:div-correla)), aunque presentan una significativa y alta correlación ($R^2=$ 0.82); mientras que el LI sobreestima la diversidad en comparación con el método **quadrat medio**. La correlación entre **point quadrat** y **quadrat medio** es baja (Figura \@ref(fig:div-correlaQM-PQ)). 


```{r div-correla, fig.cap="Correlación entre los valores de diversidad estimados por Line Intercept y los otros métodos de campo: Point Quadrat y Quadrat Medio"}

c1_div_a <- div_selected %>% 
  dplyr::select(parcela, value, metodo) %>% 
  correla_pares("Cuadrado", 
                xlab = "Diversidad (Índice de Shannon)", 
                ylab = "Diversidad (Índice de Shannon) \n Cuadrado") +
  xlim(0.5,3) + ylim(0.5,3) + 
  scale_shape_manual(values = c(19,15), name = "") +
  scale_colour_manual(values = c(color_b,color_c), name = "") + 
  scale_fill_manual(values = c(color_b,color_c), name = "") 

c1_div_a
```

#### Correlación Quadrat Medio - Point Quadrat 

```{r div-correlaQM-PQ, fig.cap="Correlación entre los valores de diversidad estimados por Quadrat Medio y Point Quadrat."}
c1_div_b <- div_selected %>% 
  dplyr::select(parcela, value, metodo) %>% 
  filter(metodo %in% c("Line intercept","Point quadrat")) %>% 
  correla_pares("Line intercept", 
                xlab = "Diversidad (Índice de Shannon) \n Point Quadrat", 
                ylab = "Diversidad (Índice de Shannon) \n Line intercept") + 
  xlim(.5,3) + ylim(.5,3) + 
  scale_shape_manual(values = 17, name = "") +
  scale_colour_manual(values = color_a, name = "") + 
  scale_fill_manual(values = color_a, name = "") +
  theme(legend.position = "none")

c1_div_b
```

# Objetivo 3. Tecnológico 

## Cobertura dronQ ~ quadrats 

```{r}
cob_dronq <- cob_qlonger %>% dplyr::select(-zona) %>% 
  rename(metodo = name)

cob_dronq <- cob_q %>% 
  dplyr::select(id = quadrat, plot, dronQ = dron) %>% 
  rename(parcela = id) %>% 
  rename(quadrat = plot) %>% 
  pivot_longer(cols = c("dronQ", "quadrat")) %>% 
  rename(metodo = name)
```

### Summary values 
```{r cobdq-resumen}
scob <- cob_dronq %>% 
  group_by(metodo) %>% 
  summarise(mean = mean(value, na.rm = TRUE), 
            sd = sd(value, na.rm = TRUE), 
            se = sd/sqrt(length(value)),
            cv = sd/mean*100,
            median = median(value, na.rm=TRUE),
            min = min(value), 
            max = max(value),
            n = length(value))

scob %>% kable(digits = 2,
               caption = "Cobertura || Summary") %>% 
    kable_paper("hover", full_width = F)
```

### Comparación de métodos 

```{r}
# normalidad
s <- shapiro.test(cob_dronq$value)

# homocedasticidad
b <- bartlett.test(cob_dronq$value, cob_dronq$metodo, data=cob_dronq)

```

Los datos no son normales (`r paste0("W = ",round(s$statistic,2),  "; ",  scales::pvalue(s$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`); pero si se cumple la  homocedasticidad (`r paste0("Bartlett's K-squared = ", round(b$statistic, 2),"; ", scales::pvalue(b$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`). Aplicamos una comparación no paramétrica (Wilcoxon Test), y observamos que existen diferencias significativas entre los valores de cobertura estimados en los **quadrats** frente a los estimados por el **dronQ** (Tabla \@ref(tab:cobdq-test)). La cobertura estimada por **quadrat** presentan valores de la mediana superiores a los estimados con **dronQ** (Figura \@ref(fig:cobdronq-violin)). 

```{r cobdq-test}
cob_dronq_w <- wilcox.test(value ~ metodo, data = cob_dronq) 

broom::tidy(cob_dronq_w) %>% 
  mutate(p.value = scales::pvalue(p.value, accuracy = 0.001)) %>% 
  kbl(caption = "DronQ ~ Quadrat || Wilcoxon Comparison test") %>% 
  kable_paper("hover", full_width = F)
```


```{r cobdronq-violin, fig.cap="Comparación de los valores de cobertura entre DronQ y Quadrat."}


cob_dronq <- cob_dronq %>% 
  mutate(metodo = 
           fct_recode(metodo, 
                      "Cuadrado" = "quadrat",
                      "Dron" = "dronQ"))

set.seed(123)
tec_cob <- ggbetweenstats(cob_dronq, 
               x = metodo, 
               y= value, 
               type = "np",
               xlab = "Método",
               ylab="Cobertura (%)",
               p.adjust.method = "bonferroni", 
               pairwise.display = "s") + theme(axis.title = element_text(face = "plain"))

tec_cob
```

### Correlación 

```{r}
cobdronq.rmse <- cob_dronq %>% 
  pivot_wider(values_from = value, names_from = metodo) %>% 
  summarise(
    rmse = round(
    Metrics::rmse(Dron, Cuadrado),4),
    min = min(Cuadrado), 
    max = max(Cuadrado),
    rmsen.minmax = rmse / (max(Cuadrado) - min(Cuadrado))*100)
```

Observamos una alta correlación significativa entre los valores de cobertura estimados por **dronQ** y los estimados en campo por los **quadrats** ($R^2=$ 0.82) (\@ref(fig:cobdronq-correla-general), aunque observamos que el **quadrat** sobreestima los valores dados por el **dronQ**. Asimismo observamos un valor de RMSE de `r round(cobdronq.rmse$rmse,2)` (y un valor de RMSE normalizado de `r round(cobdronq.rmse$rmsen.minmax,2)`) (Tabla \@ref(tab:cobdronq-rmse)). 


```{r cobdronq-correla-general, fig.cap="Correlación entre los valores de cobertura estimados por dronQ y Quadrat."}
tec_cob_b <- cob_dronq %>%
  dplyr::select(parcela, value, metodo) %>% 
  correla_pares("Dron", 
                xlab = expression('Cobertura'['Cuadrado']*' (%)'),  
                ylab = expression('Cobertura'['Dron']*' (%)')) + 
  xlim(0,100) + ylim(0,100) + 
  scale_shape_manual(values = 19, name = "") +
  scale_colour_manual(values = color_a, name = "") + 
  scale_fill_manual(values = color_a, name = "") +
  theme(legend.position = "none")

tec_cob_b 
```

```{r cobdronq-rmse}
cobdronq.rmse %>% kbl(caption = "Cobertura || RMSE",
                digits = c(2,0,0,2)) %>% 
  kable_paper("hover", full_width = F)
```

#### Partición de la varianza 

¿Es la relación entre dronQ-Quadrat uniforme a lo largo de todos los valores de cobertura o existen grupos dentro de esta correlación? Dicho de otro modo, ¿la correlación entre las dos variables es homogénea a lo largo de todos los valores de cobertura?. Para ello aplicamos una técnica de partición de la varianza, y hacemos árboles de clasificación.

```{r}
dfcob_dronq <- cob_dronq %>% 
  pivot_wider(values_from = value, names_from = metodo)

ct <- partykit::ctree(Dron ~ quadrat, data = dfcob_dronq)
ct
sctest(ct) 
```

Los resultados indican Nos indica que existen al menos 5 grupos (Figura \@ref(fig:cobdronq-party5). Sin embargo, podemos estar sobreparametrizando. Para ello evaluamos si existe *overfitting*: 

- Hacer crecer un árbol sobre cierto nivel de complejidad, puede llevarnos a sobreparametrizar el modelo. ¿En que nodo cortamos el árbol? 

- Es preferible tener un modelo más simple que sobreparametrizar el ajuste. Para ello podemos utilizar el ***Complexity parameter (CP)***, que controla el tamaño del árbol de decisión. Si el coste de añadir otro nodo (u otra variable) a partir del nodo actual está por encima del valor del cp, entonces el árbol no continúa creciendo. Mas información [aquí](https://statinfer.com/203-3-10-pruning-a-decision-tree-in-r/). 


```{r cobdronq-party5, fig.cap="Relación entre la cobertura estimada con DronQ y con Quadrat. Partición de la varianza (modelo global)"}
ggparty(ct) + 
  geom_edge() +
  geom_edge_label(colour = "grey", size = 4) +
  geom_node_plot(gglist = list(
    geom_point(aes(x = quadrat,y = Dron)),
    geom_smooth(aes(x = quadrat, y= Dron), method = lm, se = FALSE),
    geom_abline(slope = 1, colour = "gray"),
    theme_bw(base_size = 10),
    xlab(expression('Cobertura'['quadrat']*' (%)')),
    ylab(expression('Cobertura'['dronQ']*' (%)')) 
    ),
                scales = "fixed", 
                shared_axis_labels = TRUE,
                shared_legend = TRUE,
                legend_separator = TRUE, 
                id = "terminal") +
   geom_node_label(aes(col = splitvar),
                  line_list = list(aes(label = paste("Node", id)),
                                   aes(label = splitvar),
                                   aes(label = scales::pvalue(p.value, accuracy = 0.001, 
                                                              decimal.mark = ".", 
                                                              add_p = TRUE))), 
                                                     
          line_gpar = list(list(size = 8, col = "black", fontface = "bold"),
                                   list(size = 8),
                                   list(size = 8)),
                  ids = "inner") + 
  geom_node_label(aes(label = paste0("Node ", id, ", (n= ", nodesize, ")")),
                  fontface = "bold",
                  ids = "terminal",
                  size = 2, 
                  nudge_y = 0.01) +
  theme(legend.position = "none")
```

```{r cobdronq-error5}
set.seed(123)
ctrpart <- rpart(Dron ~ quadrat, data = dfcob_dronq)
printcp(ctrpart) %>% 
  kbl(caption = "CP Error - Modelo global Cobertura",
      digits = c(4,0,3,3,4)) %>% 
  kable_paper("hover", full_width = F)

```

Al explorar este modelo observamos que el error (xerror) (Tabla \@ref(tab:cobdronq-error5)) no se disminuye sustancialmente a partir del 3 item (nsplit = 2) (Figura \@ref(fig:cobdronq-error5plot)). Por tanto volvemos a modelar, usando un cp = 0.22.  

```{r cobdronq-error5plot, fig.cap="Error relativo frente a CP del modelo de partición de la varianza completo de la cobertura"}
plotcp(ctrpart)
```

```{r}
set.seed(123)
ctrpart2 <- rpart(Dron ~ quadrat, data = dfcob_dronq, control = 
               rpart.control(minsplit = 2, cp=0.22))

printcp(ctrpart2) %>% 
  kbl(caption = "CP Error - Modelo global Cobertura",
      digits = c(4,0,3,3,4)) %>% 
  kable_paper("hover", full_width = F)

```

```{r cobdronq-party, fig.cap="Relación entre la cobertura estimada con DronQ y con Quadrat. Partición de la varianza (modelo final)"}
set.seed(123)
ct_ok <- partykit::ctree(Dron ~ quadrat, data = dfcob_dronq,
                         control = partykit::ctree_control(minsplit= 1,alpha = 0.05, maxdepth = 1))

ggparty(ct_ok) + 
  geom_edge() +
  geom_edge_label(colour = "grey", size = 4) + 
  geom_node_plot(gglist = list(
    geom_point(aes(x = quadrat,y = Dron)),
    geom_smooth(aes(x=quadrat, y=Dron), method = lm, se = FALSE),
    geom_abline(slope = 1, colour = "gray"),
    theme_bw(base_size = 10),
    xlab(expression('Cobertura'['campo']*' (%)')),
    ylab(expression('Cobertura'['dron']*' (%)')) 
    ),
                scales = "fixed", 
                shared_axis_labels = TRUE,
                shared_legend = TRUE,
                legend_separator = TRUE, 
                id = "terminal") +
   geom_node_label(aes(col = splitvar),
                  line_list = list(aes(label = paste("Node", id)),
                                   aes(label = splitvar),
                                   aes(label = scales::pvalue(p.value, accuracy = 0.001, 
                                                              decimal.mark = ".", 
                                                              add_p = TRUE))), 
                                                     
          line_gpar = list(list(size = 8, col = "black", fontface = "bold"),
                                   list(size = 8),
                                   list(size = 8)),
                  ids = "inner") + 
  geom_node_label(aes(label = paste0("Node ", id, ", (n= ", nodesize, ")")),
                  fontface = "bold",
                  ids = "terminal",
                  size = 2, 
                  nudge_y = 0.01) +
  theme(legend.position = "none")

```

```{r}
verde_claro <- "#c6ddb3"
verde_oscuro <- "#3e6c62"

g <- ggparty(ct_ok) + 
  geom_edge() +
  geom_edge_label(colour = verde_oscuro, size = 4) + 
  geom_node_plot(gglist = list(
    geom_point(aes(x = quadrat,y = Dron), size = 3, colour = verde_claro, alpha = .8),
    geom_smooth(aes(x=quadrat, y=Dron), method = lm, se = FALSE, 
                colour = "gray"),
    geom_abline(slope = 1, colour = verde_oscuro),
    theme_bw(base_size = 12),
    theme(panel.grid = element_blank()),
    xlab(expression('Cobertura'['campo']*' (%)')),
    ylab(expression('Cobertura'['dron']*' (%)')) 
    ),
                scales = "fixed", 
                shared_axis_labels = TRUE,
                shared_legend = TRUE,
                legend_separator = TRUE, 
                id = "terminal") +
   geom_node_label(
                  line_list = 
                    list(aes(label = paste("Node", id)),
                         aes(label = splitvar),
                         aes(label = scales::pvalue(p.value, 
                                                    accuracy = 0.001, 
                                                    decimal.mark = ".", 
                                                    add_p = TRUE))), 
                                                     
          line_gpar = list(list(size = 8, col = verde_oscuro, 
                                fontface = "bold"),
                                   list(size = 12),
                                   list(size = 12)),
                  ids = "inner") + 
  geom_node_label(aes(label = paste0("n = ", nodesize)),
                  # fontface = "bold",
                  ids = "terminal",
                  size = 3, 
                  nudge_y = 0.01) +
  theme(legend.position = "none")



ggsave(g,
       filename = "/Users/ajpelu/Desktop/party_claro.png",
       device = "png", height = 10, width =14, unit="cm", dpi = "print",
       bg = "transparent")
```



```{r cobdronq-correla-partida, fig.cap="Correlación entre los valores de cobertura estimados por dronQ y Quadrat, considerando dos grupos (Coberturas inferiores (azul) y superiores (negro) a 36 % (en campo)."}
ff <- dfcob_dronq %>% 
  mutate(clase = case_when(
    quadrat <= 36 ~ as.character("cob_low"),
    TRUE ~ "cob_high"
  ))

ggscatter(ff, 
          x = "quadrat", 
          y = "Dron",
          add = "reg.line",
  conf.int = TRUE, 
  color = "clase", shape = "clase", 
  xlab = expression('Cobertura'['campo']*' (%)'), 
  ylab = expression('Cobertura'['dron']*' (%)')) + 
  xlim(0,100) + ylim(0,100) + 
  stat_cor(
    label.y.npc="top", label.x.npc = "left",
    aes(color = clase, 
        label = paste(..rr.label.., ..p.label.., sep = "~`,`~")),
    p.accuracy = 0.001,
    r.accuracy = 0.001
    )  + 
  geom_abline(slope = 1) + 
  scale_shape_manual(values = c(19,19), name = "") +
  scale_colour_manual(values = c("black","blue"), name = "") + 
  scale_fill_manual(values = c("black","blue"), name = "") 
  

```

```{r cobdronq-rmsegrupos}
dff.rmse_groups <- ff %>% group_by(clase) %>% 
  summarise(rmse = round(
    Metrics::rmse(Dron, quadrat),4),
    min = min(quadrat), 
    max = max(quadrat),
    rmsen.minmax = rmse / (max(quadrat) - min(quadrat))*100)

dff.rmse_groups %>% 
  kbl(caption = "Cobertura (por grupos) || RMSE",
                digits = c(0, 2,0,0,2)) %>% 
  kable_paper("hover", full_width = F)

```


## Cobertura dronT ~ LI y PQ  

```{r}
cob_p <- cob %>% 
  filter(metodo %in% c("dronT", "Line intercept", "Point quadrat")) %>% 
  dplyr::select(metodo, value, parcela) 
```

### Summary values 
```{r cobdparcela-resumen}
scobparcela <- cob_p %>% 
  group_by(metodo) %>% 
  summarise(mean = mean(value, na.rm = TRUE), 
            sd = sd(value, na.rm = TRUE), 
            se = sd/sqrt(length(value)),
            cv = sd/mean*100,
            median = median(value, na.rm=TRUE),
            min = min(value), 
            max = max(value),
            n = length(value))

scobparcela %>% kable(digits = 2,
               caption = "Cobertura dron Parcela || Summary") %>% 
    kable_paper("hover", full_width = F)
```

### Comparación de métodos 

- ANOVA Kruskal Wallis 

```{r cobdparcela-kw}
kw_cobp <- cob_p %>% 
     filter(metodo %in% c("dronT", "Line intercept", "Point quadrat")) %>%
  mutate(metodo = fct_relevel(metodo, 
                              c("Line intercept",
                                "Point quadrat", 
                                "dronT"))) %>% 
  rename(cobertura = value) %>% 
  comparaKW('cobertura', 'metodo', alpha_posthoc = 0.05)

kw_cobp$KW %>% kbl(caption = "Cobertura Parcela || Non-parametric Kruskal-Wallis ANOVA") %>% 
  kable_paper("hover", full_width = F)
```


Los resultados de la ANOVA no paramétrica (Kruskal-Wallis) indican que existen diferencias significativas para la cobertura (%) entre los diferentes métodos de campo empleados ($\chi^2$ = `r paste0(round(kw_cobp$KW$statistic,2),"; ", scales::pvalue(kw_cobp$KW$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`) (Tabla \@ref(tab:cobdparcela-kw)).


Posteriormente, evaluamos si existen diferencias entre cada uno de los métodos (*post hoc*) y observamos que existen diferencias significativas entre el **point quadrat** y los otros métodos (**line intercept** y **dron Parcela**) (Tabla \@ref(tab:cobdparcela-ph), Figura \@ref(fig:cobdparcela-violin)). Asimismo, no observamos diferencias entre la cobertura estimada según el line intercept y el dron Parcela. 

```{r cobdparcela-ph}
kw_cobp$post_hoc %>% 
  mutate(p.value = scales::pvalue(p.value, accuracy = 0.001)) %>% 
  kable(digits = c(0,2,4), caption = "Cobertura Parcela || Non-parametric Kruskal-Wallis ANOVA - Post-hoc Dunn's-test with Bonferroni adjustment") %>% 
    kable_paper("hover", full_width = F)
```


```{r cobdparcela-violin, fig.cap="Comparación de los valores de cobertura entre los diferentes métodos de campo."}
set.seed(123)

cob_p <- cob_p %>% 
  mutate(metodo = fct_recode(metodo, 
                             "Dron" = "dronT"))


tec2_cob <- ggbetweenstats(cob_p, 
               x = metodo, 
               y= value, 
               xlab = "Método", 
               type = "np",
               ylab = "Cobertura (%)", 
               p.adjust.method = "bonferroni", 
               pairwise.display = "s", 
               centrality.label.args = list(size = 3, nudge_x = -0.4)) +
  theme(axis.title = element_text(face = "plain"))

tec2_cob

```

### Correlación 

Tanto **line intercept** como **point quadrat** subestiman los valores de cobertura dados por el dron en la parcela de 500 m^2 (Figura \@ref(fig:cobdparcela-correla)). Independientemente no presentan buenas correlaciones con el valor de cobertura estimado por el dron para toda la parcela. 

```{r cobdparcela-correla, fig.cap="Correlación entre los valores de cobertura estimados por dronParcela con respecto a Line Intercept y Point Quadrat."}
tec2_cob_b <- cob_p %>% 
  correla_pares("Dron", 
                 xlab=expression('Cobertura (%)'),
                ylab=expression('Cobertura'['dron 500 '*m^2]*' (%)')) + 
  ylim(c(0,65)) + 
  xlim(c(0,65)) +
  scale_shape_manual(values = c(19,15), name = "") +
  scale_colour_manual(values = c(color_b,color_c), name = "") + 
  scale_fill_manual(values = c(color_b,color_c), name = "")

tec2_cob_b
```






## Fitovolumen dronQ ~ quadrats 

```{r}
fit_dronq <- fit_qlonger %>% dplyr::select(-zona) %>% 
  rename(metodo = name)
```

### Summary values 
```{r fitdq-resumen}
sfit <- fit_dronq %>% 
  group_by(metodo) %>% 
  summarise(mean = mean(value, na.rm = TRUE), 
            sd = sd(value, na.rm = TRUE), 
            se = sd/sqrt(length(value)),
            cv = sd/mean*100,
            median = median(value, na.rm=TRUE),
            min = min(value), 
            max = max(value),
            n = length(value))

sfit %>% kable(digits = 2,
               caption = "Fitovolumen || Summary") %>% 
    kable_paper("hover", full_width = F)
```

### Comparación de métodos 

```{r}
# normalidad
s <- shapiro.test(fit_dronq$value)

# homocedasticidad
b <- bartlett.test(fit_dronq$value, fit_dronq$metodo, data=fit_dronq)

```

Los datos no son normales (`r paste0("W = ",round(s$statistic,2),  "; ",  scales::pvalue(s$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`) ni homocedasticos (`r paste0("Bartlett's K-squared = ", round(b$statistic, 2),"; ", scales::pvalue(b$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`). Aplicamos una comparación no paramétrica (Wilcoxon Test), y observamos que existen diferencias significativas entre los valores de fitovolumen estimados en los **quadrats** frente a los estimados por el **dronQ** (Tabla \@ref(tab:fitdq-test)). La cobertura estimada por **quadrat** presentan valores de la mediana superiores a los estimados con **dronQ** (Figura \@ref(fig:fitdronq-violin)). 

```{r fitdq-test}
fit_dronq_w <- wilcox.test(value ~ metodo, data = fit_dronq) 

broom::tidy(fit_dronq_w) %>% 
  mutate(p.value = scales::pvalue(p.value, accuracy = 0.001)) %>% 
  kbl(caption = "Fitovolumen DronQ ~ Quadrat || Wilcoxon Comparison test") %>% 
  kable_paper("hover", full_width = F)
```


```{r fitdronq-violin, fig.cap="Comparación de los valores de fitovolumen entre DronQ y Quadrat."}

fit_dronq <- fit_dronq %>% 
  mutate(metodo = 
           fct_recode(metodo, 
                      "Cuadrado" = "quadrat",
                      "Dron" = "dronQ"))

set.seed(123)
tec_fit <- ggbetweenstats(fit_dronq, 
               x = metodo, 
               y= value, 
               type = "np",
               xlab= "Método",
               ylab=expression(Fitovolumen~(m^3~ha^{-1})),
               p.adjust.method = "bonferroni", 
               pairwise.display = "s") +
  theme(axis.title.x = element_text(face = "plain"))
tec_fit
```


### Correlación 

```{r}
fitdronq.rmse <- fit_q %>% 
  dplyr::select(id = quadrat, plot, dronQ=dron) %>% 
  rename(parcela = id, quadrat = plot) %>% 
  summarise(
    rmse = round(
    Metrics::rmse(dronQ, quadrat),4),
    min = min(quadrat), 
    max = max(quadrat),
    rmsen.minmax = rmse / (max(quadrat) - min(quadrat))*100)
```

Observamos una alta correlación significativa entre los valores de fitovolumen estimados por **dronQ** y los estimados en campo por los **quadrats** ($R^2=$ 0.9) (\@ref(fig:fitdronq-correla-general), aunque observamos que el **quadrat** sobreestima los valores dados por el **dronQ**. Los valores de RMSE son de `r round(fitdronq.rmse$rmse,2)` (y un valor de RMSE normalizado de `r round(fitdronq.rmse$rmsen.minmax,2)`) (Tabla \@ref(tab:fitdronq-rmse)). 


```{r fitdronq-correla-general, fig.cap="Correlación entre los valores de fitovolumen estimados por dronQ y Quadrat."}

tec_fit_b <- fit_q %>% dplyr::select(id = quadrat, plot, dronQ=dron) %>%
  rename(parcela = id, quadrat = plot) %>%  
  rename(Dron = dronQ, Cuadrado = quadrat) %>% 
  pivot_longer(cols = c("Dron", "Cuadrado")) %>% 
  rename(metodo = name) %>% 
  correla_pares("Dron", 
 ylab=expression(Fitovolumen[Dron]~(m^3~ha^{-1})),
 xlab=expression(Fitovolumen[Cuadrado]~(m^3~ha^{-1}))) +
  scale_shape_manual(values = 19, name = "") +
  scale_colour_manual(values = color_a, name = "") + 
  scale_fill_manual(values = color_a, name = "") +
  theme(legend.position = "none")

tec_fit_b

```

```{r fitdronq-rmse}
fitdronq.rmse %>% kbl(caption = "Fitovolumen || RMSE",
                digits = c(2,0,0,2)) %>% 
  kable_paper("hover", full_width = F)
```

#### Partición de la varianza 

¿Es la relación entre dronQ-Quadrat uniforme a lo largo de todos los valores de cobertura o existen grupos dentro de esta correlación? Dicho de otro modo, ¿la correlación entre las dos variables es homogénea a lo largo de todos los valores de cobertura?. Para ello aplicamos una técnica de partición de la varianza, y hacemos árboles de clasificación.

```{r}
dffit_dronq <- fit_q %>% 
  dplyr::select(id = quadrat, plot, dronQ=dron) %>%
  rename(parcela = id, quadrat = plot) 

ctfit <- partykit::ctree(dronQ ~ quadrat, data = dffit_dronq)
ctfit
sctest(ctfit) 
```

Los resultados indican Nos indica que existen al menos 4 grupos (Figura \@ref(fig:fitdronq-party4). Sin embargo, podemos estar sobreparametrizando. Para ello evaluamos si existe *overfitting*: 

- Hacer crecer un árbol sobre cierto nivel de complejidad, puede llevarnos a sobreparametrizar el modelo. ¿En que nodo cortamos el árbol? 

- Es preferible tener un modelo más simple que sobreparametrizar el ajuste. Para ello podemos utilizar el ***Complexity parameter (CP)***, que controla el tamaño del árbol de decisión. Si el coste de añadir otro nodo (u otra variable) a partir del nodo actual está por encima del valor del cp, entonces el árbol no continúa creciendo. Mas información [aquí](https://statinfer.com/203-3-10-pruning-a-decision-tree-in-r/). 


```{r fitdronq-party4, fig.cap="Relación entre el fitovolumen estimado con DronQ y con Quadrat. Partición de la varianza (modelo global)"}
ggparty(ctfit) + 
  geom_edge() +
  geom_edge_label(colour = "grey", size = 4) +
  geom_node_plot(gglist = list(
    geom_point(aes(x = quadrat,y = dronQ)),
    geom_smooth(aes(x = quadrat, y=dronQ), method = lm, se = FALSE),
    geom_abline(slope = 1, colour = "gray"),
    theme_bw(base_size = 10),
 ylab(expression(Fitovolumen[dronQ]~(m^3~ha^{-1}))),
 xlab(expression(Fitovolumen[quadrat]~(m^3~ha^{-1})))),
                scales = "fixed", 
                shared_axis_labels = TRUE,
                shared_legend = TRUE,
                legend_separator = TRUE, 
                id = "terminal") +
   geom_node_label(aes(col = splitvar),
                  line_list = list(aes(label = paste("Node", id)),
                                   aes(label = splitvar),
                                   aes(label = scales::pvalue(p.value, accuracy = 0.001, 
                                                              decimal.mark = ".", 
                                                              add_p = TRUE))), 
                                                     
          line_gpar = list(list(size = 8, col = "black", fontface = "bold"),
                                   list(size = 8),
                                   list(size = 8)),
                  ids = "inner") + 
  geom_node_label(aes(label = paste0("Node ", id, ", (n= ", nodesize, ")")),
                  fontface = "bold",
                  ids = "terminal",
                  size = 2, 
                  nudge_y = 0.01) +
  theme(legend.position = "none")
```

```{r fitdronq-error4}
set.seed(123)
ctfitrpart <- rpart(dronQ ~ quadrat, data = dffit_dronq)
printcp(ctfitrpart) %>% 
  kbl(caption = "CP Error - Modelo global Fitvolumen",
      digits = c(4,0,3,3,4)) %>% 
  kable_paper("hover", full_width = F)

```

Al explorar este modelo observamos que el error (xerror) (Tabla \@ref(tab:fitdronq-error4)) no se disminuye sustancialmente a partir del 2 item (nsplit = 1) (Figura \@ref(fig:fitdronq-error4plot)). Por tanto volvemos a modelar, usando un cp = 0.3.  

```{r fitdronq-error4plot, fig.cap="Error relativo frente a CP del modelo de partición de la varianza completo del fitovolumen"}
plotcp(ctfitrpart)
```

```{r}
set.seed(123)
ctfitrpart2 <- rpart(dronQ ~ quadrat, data = dffit_dronq, control = 
               rpart.control(minsplit = 2, cp=0.3))

printcp(ctfitrpart2) %>% 
  kbl(caption = "CP Error - Modelo global Fitovolumen",
      digits = c(4,0,3,3,4)) %>% 
  kable_paper("hover", full_width = F)

```

```{r fitdronq-party, fig.cap="Relación entre el fitovolumen estimado con DronQ y con Quadrat. Partición de la varianza (modelo final)"}
set.seed(123)
ctfit_ok <- partykit::ctree(dronQ ~ quadrat, data = dffit_dronq,
                         control = partykit::ctree_control(minsplit= 1,alpha = 0.05, maxdepth = 2))

ggparty(ctfit_ok) + 
  geom_edge() +
  geom_edge_label(colour = "grey", size = 4) + 
  geom_node_plot(gglist = list(
    geom_point(aes(x = quadrat,y = dronQ)),
    geom_smooth(aes(x=quadrat, y=dronQ), method = lm, se = FALSE),
    geom_abline(slope = 1, colour = "gray"),
    theme_bw(base_size = 10),
    ylab(expression(Fitovolumen[dronQ]~(m^3~ha^{-1}))),
 xlab(expression(Fitovolumen[quadrat]~(m^3~ha^{-1}))) 
    ),
                scales = "fixed", 
                shared_axis_labels = TRUE,
                shared_legend = TRUE,
                legend_separator = TRUE, 
                id = "terminal") +
   geom_node_label(aes(col = splitvar),
                  line_list = list(aes(label = paste("Node", id)),
                                   aes(label = splitvar),
                                   aes(label = scales::pvalue(p.value, accuracy = 0.001, 
                                                              decimal.mark = ".", 
                                                              add_p = TRUE))), 
                                                     
          line_gpar = list(list(size = 8, col = "black", fontface = "bold"),
                                   list(size = 8),
                                   list(size = 8)),
                  ids = "inner") + 
  geom_node_label(aes(label = paste0("Node ", id, ", (n= ", nodesize, ")")),
                  fontface = "bold",
                  ids = "terminal",
                  size = 2, 
                  nudge_y = 0.01) +
  theme(legend.position = "none")
```


```{r fitdronq-correla-partida, fig.cap="Correlación entre los valores de fitovolumen estimados por dronQ y Quadrat, considerando dos grupos (Fitovolumen inferiores (azul) y superiores (negro) a 681 % (en campo)."}
fffit <- dffit_dronq %>% 
  mutate(clase = case_when(
    quadrat <= 681 ~ as.character("fit_low"),
    TRUE ~ "fit_high"
  ))

ggscatter(fffit, 
          x = "quadrat", 
          y = "dronQ",
          add = "reg.line",
  conf.int = TRUE, 
  color = "clase", shape = "clase", 
  ylab =expression(Fitovolumen[dronQ]~(m^3~ha^{-1})),
 xlab = expression(Fitovolumen[quadrat]~(m^3~ha^{-1}))) + 
  # xlim(0,100) + ylim(0,100) + 
  stat_cor(
    label.y.npc="top", label.x.npc = "left",
    aes(color = clase, 
        label = paste(..rr.label.., ..p.label.., sep = "~`,`~")),
    p.accuracy = 0.001,
    r.accuracy = 0.001
    )  + 
  geom_abline(slope = 1) + 
  scale_shape_manual(values = c(19,19), name = "") +
  scale_colour_manual(values = c("black","blue"), name = "") + 
  scale_fill_manual(values = c("black","blue"), name = "") 
  

```

```{r fitdronq-rmsegrupos}
dfffit.rmse_groups <- fffit %>% group_by(clase) %>% 
  summarise(rmse = round(
    Metrics::rmse(dronQ, quadrat),4),
    min = min(quadrat), 
    max = max(quadrat),
    rmsen.minmax = rmse / (max(quadrat) - min(quadrat))*100)

dfffit.rmse_groups %>% 
  kbl(caption = "Fitovolumen (por grupos) || RMSE",
                digits = c(0, 2,0,0,2)) %>% 
  kable_paper("hover", full_width = F)

```




## Fitovolumen dronT ~ LI

```{r}
fit_p <- fit_tlonger %>%  
  dplyr::select(metodo =name, value, parcela) 
```

### Summary values 
```{r fitdparcela-resumen}
sfitparcela <- fit_p %>% 
  group_by(metodo) %>% 
  summarise(mean = mean(value, na.rm = TRUE), 
            sd = sd(value, na.rm = TRUE), 
            se = sd/sqrt(length(value)),
            cv = sd/mean*100,
            median = median(value, na.rm=TRUE),
            min = min(value), 
            max = max(value),
            n = length(value))

sfitparcela  %>% kable(digits = 2,
               caption = "Fitovolumen dron Parcela || Summary") %>% 
    kable_paper("hover", full_width = F)
```

### Comparación de métodos 

```{r}
# normalidad
s <- shapiro.test(fit_p$value)

# homocedasticidad
b <- bartlett.test(fit_p$value, fit_p$metodo, data=fit_p)

```

Los datos son normales (`r paste0("W = ",round(s$statistic,2),  "; ",  scales::pvalue(s$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`); pero no se cumple la  homocedasticidad (`r paste0("Bartlett's K-squared = ", round(b$statistic, 2),"; ", scales::pvalue(b$p.value, accuracy = 0.0001, decimal.mark = ".", add_p = TRUE))`). Aplicamos una comparación no paramétrica (Wilcoxon Test), y observamos que **no** existen diferencias significativas entre los valores de fitovolumen estimados en el **line intercept** frente a los estimados por el **dronT** (parcela) (Tabla \@ref(tab:fitdp-test); Figura \@ref(fig:fitdp-violin)). 

```{r fitdp-test}
fit_p_w <- wilcox.test(value ~ metodo, data = fit_p) 

broom::tidy(fit_p_w) %>% 
  mutate(p.value = scales::pvalue(p.value, accuracy = 0.001)) %>% 
  kbl(caption = "Fitovolumen DronT ~ Line Intercept || Wilcoxon Comparison test") %>% 
  kable_paper("hover", full_width = F)
```


```{r fitdp-violin, fig.cap="Comparación de los valores de fitovolumen entre Dron Parcela y Line Intercept."}

set.seed(123)

tec2_fit_a <- fit_p %>% 
  mutate(metodo = fct_recode(metodo, 
                             "Line intercept" = "line_intercept",
                             "Dron" = "dronT")) %>%
  ggbetweenstats( 
               x = metodo, 
               y= value, 
               type = "np",
               xlab = "Método",
               ylab=expression(Fitovolumen~(m^3~ha^{-1})),
               p.adjust.method = "bonferroni", 
               pairwise.display = "s") 

tec2_fit_a
```


### Correlación 

No existe una buena correlación entre los valores de fitovolumen ofrecidos por **line intercept** y los datos por el dron en la parcela de 500 m^2 (Figura \@ref(fig:fitdparcela-correla)). 

```{r fitdparcela-correla, fig.cap="Correlación entre los valores de fitovolumen estimados por dronParcela con respecto a Line Intercept"}
tec2_fit_b <- fit_p %>% 
  mutate(metodo = fct_recode(metodo, 
                             "Line intercept" = "line_intercept",
                             "Dron" = "dronT")) %>%
  correla_pares("Dron", 
                 xlab = expression('Fitovolumen'['Line Intercept']~(m^3~ha^{-1})),
                ylab = expression('Fitovolumen'['dron 500 '*m^2]~(m^3~ha^{-1}))) + 
  ylim(c(50,1250)) + 
  xlim(c(50,1250)) +
  scale_shape_manual(values = 19, name = "") +
  scale_colour_manual(values = color_a, name = "") + 
  scale_fill_manual(values = color_a, name = "") +
  theme(legend.position = "none")

tec2_fit_b
```


# Plots para el trabajo 


```{r}
p1 <- combine_plots(
  list(p1_cob, p1_fit, p1_riq, p1_div),
  plotgrid.args = list(nrow = 2),
  annotation.args = list(
    tag_levels = "a",
    tag_suffix = ")", 
    theme = theme(plot.tag = element_text(size = 40, face = 'bold'))
  )
)

ggsave(plot = p1, 
       here::here("output/paper_SUDOE/plot_comparacion.png"),
       device = "png",
       dpi = 300,
       width = 12, height = 10)
```


```{r}
c1 <- combine_plots(
  list(c1_cob_a,c1_cob_b,
       c1_div_a, c1_div_b,
       c1_riq_a, c1_riq_b,
       c1_fit),
  plotgrid.args = list(ncol = 2), 
  annotation.args = list(
    tag_levels = "a",
    tag_suffix = ")",
    theme = theme(
      plot.margin = margin(0, 0, 0, 0, "cm"), 
      legend.position = 'bottom',
      plot.tag = element_text(size = 40, face = 'bold'))), 
  guides = 'collect')
    
ggsave(plot = c1, 
       here::here("output/paper_SUDOE/plot_correla.png"),
       device = "png",
       dpi = 300,
       width = 9, height = 12)
```


```{r}
tec <- combine_plots(
  list(tec_cob, tec_cob_b, tec_fit, tec_fit_b),
  plotgrid.args = list(nrow = 2, 
                       widths = c(.65,.35)),
  annotation.args = list(
    tag_levels = "a",
    tag_suffix = ")", 
    theme = theme(plot.tag = element_text(size = 40, face = 'bold'))
  )
)

ggsave(plot = tec, 
       here::here("output/paper_SUDOE/plot_tecnologico.png"),
       device = "png",
       dpi = 300,
       width = 9, height = 8)
```


```{r}
tec2 <- combine_plots(
  list(tec2_cob, tec2_cob_b, tec2_fit_a, tec2_fit_b),
  plotgrid.args = list(nrow = 2, 
                       widths = c(.65,.35)),
  annotation.args = list(
    tag_levels = "a",
    tag_suffix = ")", 
    theme = theme(plot.tag = element_text(size = 40, face = 'bold'),
                   legend.position = 'bottom')
  )
)

ggsave(plot = tec2, 
       here::here("output/paper_SUDOE/plot_tecnologico_LI.png"),
       device = "png",
       dpi = 300,
       width = 9, height = 8)

```


